[
"LDBrowser browser = null;\n\nvar eventHandler = {};\n\nvoid api_addEventHandler(String handler,callback)\n{\n    eventHandler[handler] = callback;\n}\n\nObject[] api_getHighlightedDataPoints() {\n    if (browser.highlightDataPoints != null) \n    	return browser.highlightDataPoints.toArray();\n    else\n       return null;\n}\n\nvoid api_clearEventHandlers()\n{\n   eventHandler = {};\n}\n\nvoid api_setData(int[] snps,float[][] r2,int start,int end) {\n    browser.setData(snps,r2,start,end);\n}   \n\nvoid api_setSize(int width,boolean isDraw) {\n    if (width==0)\n    	return;\n    browser.setSize(width,width,isDraw);\n}\n\nvoid api_setHighlightPosition(int position) {\n    browser.setHighlightPosition(position);\n}\n    \nvoid setup()\n{\n  int width=1024;\n  int height=1024;\n  int threshold = 0.3;\n  browser = new LDBrowser(width,height,threshold);\n  frameRate(1);\n  size(width,height);\n  background(0);\n  smooth();\n  noLoop();\n}\n\nvoid draw()\n{\n  background(255);\n  noFill();\n  browser.display();\n}\n    \nclass LDBrowser {\n    QuadTree quadTree;\n    ArrayList dataPoints;\n    ArrayList filteredDataPoints;\n    int[] snps = null;\n    float separation = 0;\n    int width = 100;\n    int height = 100;\n    int viewStart = 0;\n    int viewEnd = 0;\n    int zoomStart = 0;\n    int zoomEnd = 0;\n    float pxPerBp = 0;\n    float threshold = 0.3;\n    float maxHue = 60;\n    int offsetLegendX = 40;\n    int offsetLegendY = 90;\n    int snpPosBandHeight = 50;\n    int scalerLegendWidth = 50;\n    color bgrColor = null;\n    color highlightBgrColor = #C0C0C0;\n    ArrayList highlightDataPoints = new ArrayList();\n    int highlightPosition = null;\n    float scaleFactor = 1/sqrt(2);\n    float rotationFactor  = radians(-45);\n    PGraphics pg = null;\n    PGraphics pgSNPs = null;\n    \n    public LDBrowser(width,height,threshold) {\n        this.threshold = threshold;\n        colorMode(HSB, 360, 100, 100,1);\n        bgrColor = color(240,100,100);\n        Bounds bounds = new Bounds(0,0,width,height);\n        quadTree = new QuadTree(bounds,9999,50);\n    }\n    \n    \n    \n    public void setSize(int width,int height,boolean isDraw) {\n        if (this.width == width && this.height == height)\n            return;\n        size(width,width/2+snpPosBandHeight);\n        console.log('setsize'+width);\n        pg = null;\n        pgSNPs = null; \n    	this.width=width;\n        this.height=height;\n        initPxPerUnit();\n        quadTree.clear();\n        Bounds bounds = new Bounds(0,0,width,height);\n        quadTree = new QuadTree(bounds,9999,50);\n        if (filteredDataPoints != null) {\n        	quadTree.insert(filteredDataPoints);\n        }\n        if (isDraw) {\n        	draw();\n        }\n    }\n    \n    public void setHighlightDataPoints(ArrayList points) {\n        highlightDataPoints = points;\n        highlightPosition = null;\n    }\n    \n    public void setHighlightPosition(int position) {\n         if (position == null) {\n              highlightDataPoints = new ArrayList();\n              highlightPosition = null;\n              return;\n         }\n         if (filteredDataPoints == null || highlightPosition == position)\n             return;\n         highlightPosition = position;\n         ArrayList points = new ArrayList();\n         for (int i = 0; i < filteredDataPoints.size(); i++) {\n            DataPoint dataPoint = (DataPoint)filteredDataPoints.get(i);\n            if (dataPoint.getPosX() == position || dataPoint.getPosY() == position)\n                points.add(dataPoint);\n        }\n        highlightDataPoints = points;\n        draw();\n    }\n    \n    public ArrayList getHighlightDataPoints() {\n        return highlightDataPoints;\n    }\n    \n    public void setData(int[] snps,float[][] data, int viewStart,int viewEnd) {\n       this.snps = snps;\n       if (viewStart != null) \n           this.viewStart = viewStart;\n       else \n           this.viewStart = snps[0];\n        if (viewEnd != null)\n            this.viewEnd = viewEnd;\n        else \n           this.viewEnd = snps[snps.length-1];\n        initPxPerUnit();\n        pg = null;\n        pgSNPs = null;\n        dataPoints = new ArrayList(); \n        filteredDataPoints = new ArrayList();\n        for (int i = 0; i <data.length ; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n              DataPoint dataPoint = new DataPoint(0+j*separation,0+i*separation,separation,snps[j],snps[i],data[i][j]);\n              dataPoints.add(dataPoint);\n              if (data[i][j] > threshold)\n                  filteredDataPoints.add(dataPoint);\n            }\n        }\n        console.log('separation'+separation);\n        console.log(dataPoints.size());\n        console.log(filteredDataPoints.size());\n        quadTree.clear();\n        quadTree.insert(filteredDataPoints);\n        console.log(quadTree);\n        draw()\n    }\n    \n    public DataPoint getDataPointFromMousePos() {\n        float[] mousePos  = getTransformedMousePos();\n        ArrayList dataPointsToSearch = quadTree.retrieve(mousePos[0],mousePos[1]);\n    //dataPointsToSearch = filteredDataPoints;\n    // console.log(\"total items: \" + filteredDataPoints.size());\n    // console.log(\"after Quad-Tree:\"+dataPointsToSearch.size());\n        for (int i = 0; i < dataPointsToSearch.size(); i++) {\n           DataPoint dataPoint = (DataPoint)dataPointsToSearch.get(i);\n           if (isMouseInDataPoint(dataPoint,mousePos)) {\n               return dataPoint;\n           }\n        }\n        return null;\n    }\n    \n    public boolean isMouseInDataPoint(Datapoint point,int[] mousePos) {\n    /*console.log('X1:' + point.getX());\n            console.log('Y1:' + point.getY());\n            console.log('X2:' + float(point.getX() + separation)); \n            console.log('XY:' + float(point.getY() + separation));\n    console.log(separation);*/\n           if (point.getX() <= mousePos[0] && (point.getX() + separation) >= mousePos[0]\n                && point.getY() <= mousePos[1] && (point.getY() + separation) >= mousePos[1]    ) {\n       return true;\n}    \n    return false;\n    }\n    \n    public float[] getTransformedMousePos() {\n        float[] mousePos = new int[2];\n    //mousePos[0] = mouseX;\n    //  mousePos[1] = mouseY;\n    //return mousePos;\n        int r = -rotationFactor;\n    //  console.log('originalX:' + mouseX);\n    //console.log('originalY:' + mouseY);\n        int newMouseY = mouseY - snpPosBandHeight;\n        int transMouseX = mouseX * Math.cos(r) - newMouseY * Math.sin(r);\n        int transMouseY = newMouseY * Math.cos(r) + mouseX * Math.sin(r);\n        transMouseX = transMouseX * 1/scaleFactor;\n        transMouseY = transMouseY * 1/scaleFactor;\n        mousePos[0] = transMouseX;\n        mousePos[1] = transMouseY;\n        return mousePos;\n    }\n    \n    private void setupBackBuffer() {\n        if (pg == null) {\n           pg = createGraphics(width, height, P2D);\n           pg.beginDraw();\n              pg.colorMode(HSB, 360, 100, 100,1);\n              createBackground();\n              createR2Boxes();\n           pg.endDraw();\n        }\n        if (pgSNPs == null) {\n            pgSNPs = createGraphics(width, snpPosBandHeight, P2D);\n            pgSNPs.beginDraw();\n               pgSNPs.colorMode(HSB, 360, 100, 100,1);\n               createSNPsBand();\n            pgSNPs.endDraw();\n           \n        }\n    }\n    \n    private void createBackground() {\n        pg.fill(bgrColor,0.4);\n        pg.noStroke();\n        pg.rect(0,0,width,height);\n    }\n    private void createR2Boxes() {\n        for (int i = 0; i < filteredDataPoints.size(); i++) {\n            DataPoint dataPoint = (DataPoint)filteredDataPoints.get(i);\n            dataPoint.createR2Boxes(threshold,maxHue,pg);\n        }\n    }\n    \n     private void initPxPerUnit() {\n       oldseparation = separation;\n       if (snps != null)\n       	   separation = width/(snps.length);\n       if (this.zoomEnd - this.zoomStart != 0)\n             this.pxPerBp  = (float)this.width / (this.zoomEnd - this.zoomStart);\n       if (this.viewEnd - this.viewStart != 0)\n           this.pxPerBp = (float)this.width / (this.viewEnd - this.viewStart);\n       if (oldseparation != separation && dataPoints != null) {\n           console.log('update coordinates');\n           console.log('oldseparation:' + oldseparation);\n           console.log('separation:' + separation);\n           for (int i = 0;i<dataPoints.size();i++) {\n               DataPoint dataPoint = (DataPoint)dataPoints.get(i);\n               dataPoint.updateCoord(separation);\n           }\n       }\n    }\n    \n    public void display() {\n        if (filteredDataPoints == null)\n            return;\n        setupBackBuffer();\n        float alpha = 1;\n        pushMatrix();\n        translate(0,snpPosBandHeight);\n        scale(scaleFactor);\n        rotate(rotationFactor);\n        image(pg);\n        if (highlightDataPoints.size() >0) {\n            alpha = 0.4;                    \n        }\n        if (highlightDataPoints.size() >0) {\n             displayOverlay();\n             for (int i = 0; i < highlightDataPoints.size(); i++) {\n                dataPoint = (DataPoint)highlightDataPoints.get(i);\n                dataPoint.display(threshold,maxHue,1);                 \n             }\n        }\n        //quadTree.display();\n        popMatrix();\n        displaySnpPosBand();\n        displayLegend();\n    }\n    \n    private void createSNPsBand() {\n        pgSNPs.noStroke();\n        pgSNPs.fill(0,0,100);\n        pgSNPs.rect(0,0,width,snpPosBandHeight);\n        pgSNPs.stroke(0);\n        pgSNPs.line(0,0,width,0);\n        for (i=0;i<snps.length;i++) {\n            int startIndex = snps[i]-viewStart;\n            pgSNPs.line(startIndex*pxPerBp,0,0+i*separation,snpPosBandHeight);\n        }\n    }\n    \n    private void displaySnpPosBand() {\n        setupBackBuffer();\n        image(pgSNPs);\n        if (highlightDataPoints.size() >0) {\n            noStroke();\n            fill(255,0.7);\n            rect(0,0,width,snpPosBandHeight);\n            stroke(0,1);\n            if (highlightPosition != null) {\n                int i = binarySearch(snps,highlightPosition);\n     line((highlightPosition-viewStart)*pxPerBp,0,0+i*separation,snpPosBandHeight)\n            }\n            else {\n                 DataPoint point = (DataPoint)highlightDataPoints.get(0);\n                 line((point.getPosX() - viewStart)*pxPerBp,0,point.getX(),snpPosBandHeight);\n                 line((point.getPosY() - viewStart)*pxPerBp,0,point.getY(),snpPosBandHeight);\n            }\n        }\n    }\n    \n    private int binarySearch(arr, key){\n        var left = 0;\n        var right = arr.length - 1;\n        while (left <= right){\n           var mid = parseInt((left + right)/2);\n           if (arr[mid] == key)\n               return mid;\n           else if (arr[mid] < key)\n              left = mid + 1;\n           else\n              right = mid - 1;\n        }\n        return arr.length;\n     }\n    \n    \n    private void displayOverlay() {\n       noStroke();\n       fill(255,0.7);\n       rect(0,0,width,height);\n    }\n    \n    \n    private void displayLegend() {\n        int calOffsetLegendY = snpPosBandHeight +  offsetLegendY;\n        int legendHeight= height/2-calOffsetLegendY;\n        int legendWidth= height/scalerLegendWidth;\n    \n        int firstSectionHeight = legendHeight-legendHeight*threshold;\n        int tickDistance = legendHeight/10;\n        stroke(0);\n        noFill();\n        rect(offsetLegendX,calOffsetLegendY,legendWidth,legendHeight);\n        noStroke();\n        color top = color(0,100,100);\n        color bottom = color(60,100,100);\n        for (int i =0;i<=firstSectionHeight;i++) {\n            color legendColor = lerpColor(top, bottom, i/firstSectionHeight);\n            stroke(legendColor);\n      line(offsetLegendX+0.5,calOffsetLegendY+0.5+i,offsetLegendX+legendWidth-1,calOffsetLegendY+0.5+i);\n        }\n        \n        fill(bgrColor);\n        noStroke();\n        int posYForSecondHalf = calOffsetLegendY + firstSectionHeight;\n        rect(offsetLegendX+0.5,posYForSecondHalf,legendWidth-0.5,( height/2+0.5-posYForSecondHalf));\n        \n        textAlign(LEFT,CENTER);\n        for (int i = 0; i<=10;i++) {\n            stroke(0);\n            line(offsetLegendX+legendWidth-legendWidth/3,calOffsetLegendY + tickDistance*i,offsetLegendX+legendWidth,calOffsetLegendY + tickDistance*i);\n            text((1-i/10),offsetLegendX+legendWidth+5,calOffsetLegendY + tickDistance*i);\n        }\n    \n       // display VALUE\n       if (highlightDataPoints != null && highlightDataPoints.size() == 1) {\n            DataPoint dataPoint = (DataPoint) highlightDataPoints.get(0);\n            float valuePosY = calOffsetLegendY + (1-dataPoint.getR2())*legendHeight;\n            line(offsetLegendX-legendWidth/3,valuePosY,offsetLegendX+legendWidth/3,valuePosY);\n            textAlign(RIGHT,CENTER);\n            text(dataPoint.getR2(),offsetLegendX-legendWidth/3-2,valuePosY);            \n       }\n    }\n    \n}\n    \nclass DataPoint {\n   float x,y,separation;\n   int posX,posY;\n   float r2;   \n    \n  \n public DataPoint(float x,float y,float separation,int posX,int posY,float r2) {\n        this.x = x;\n        this.separation = separation;\n        this.y = y;\n        this.posX = posX;\n        this.posY = posY;\n        this.r2 = r2;\n   }\n    \n   public void display(float threshold,float maxHue,float alpha) {\n       noStroke();\n       colorMode(HSB, 360, 100, 100,1);\n       float hue = calculateHue(threshold,maxHue);\n       fill(hue,100,100,alpha);\n       rect(x,y,separation,separation);\n   }\n    \n    public void createR2Boxes(float threshold,float maxHue, PGraphics pg) {\n        pg.noStroke();\n        pg.colorMode(HSB, 360, 100, 100,1);\n        float hue = calculateHue(threshold,maxHue);\n        pg.fill(hue,100,100,1);\n        pg.rect(x,y,separation,separation);\n    }\n    \n    private float calculateHue(float threshold,float maxHue) {\n         float hue = (1 - (r2 - threshold)/(1-threshold))*maxHue;\n         if (hue < 0)\n            hue=0;\n         return hue;\n    }\n    \n    public float getR2() {\n       return r2;\n    }\n    \n    public float getX() {\n        return x;\n    }\n    public float getY() {\n        return y;\n    }\n    \n    public int getPosY() {\n        return posY;\n    }\n    public int getPosX() {\n        return posX;\n    }\n    \n    public float getSeparation() {\n        return separation;\n    }\n    \n    public void updateCoord(float separation) {\n        if(this.separation != separation) {\n            if (this.separation != 0) {\n            	this.x = this.x/this.separation*separation;\n            	this.y = this.y/this.separation*separation;\n            }\n            else {\n                this.x = this.x*separation;\n            	this.y = this.y*separation;\n            }\n            this.separation = separation;\n        }\n    }\n    \n }\n    \n void mouseMoved() {\n    ArrayList points = new ArrayList();\n    if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {\n        browser.setHighlightDataPoints(points);\n        if (eventHandler['unhighlightEvent'] != null)\n        	eventHandler['unhighlightEvent']();\n        draw();\n    }\n    DataPoint point = browser.getDataPointFromMousePos();\n    \n    if (browser.getHighlightDataPoints() != null && browser.getHighlightDataPoints().size() == 1\n        && ((DataPoint)browser.getHighlightDataPoints().get(0)) == point)   \n        return;\n    \n    if (point != null)\n       points.add(point);\n    if (points.size() == 1) {\n       if (eventHandler['highlightEvent'] != null)\n        	eventHandler['highlightEvent'](point);\n    }\n    else {\n       if (eventHandler['unhighlightEvent'] != null)\n        	eventHandler['unhighlightEvent']();\n    }\n    browser.setHighlightDataPoints(points);\n    draw();\n}\n\nvoid mouseReleased()\n{\n	if (mouseButton == CENTER) \n	{\n		 if (eventHandler['middleMouseClickEvent'] != null)\n       	     eventHandler['middleMouseClickEvent']();\n	} \n}\n    \nclass QuadTree {\n    Node root;\n    int maxDepth = 4;\n    \n    public QuadTree(Bounds bounds,int maxDepth,int maxChildren) {\n        root = new Node(bounds,0,maxDepth,maxChildren);\n    }\n    \n    public void insert(ArrayList dataPoints) {\n        for (int i =0;i<dataPoints.size();i++) {\n            insertSingle((DataPoint)dataPoints.get(i));\n        }   \n    }\n    public void insertSingle(DataPoint dataPoint) {\n        root.insert(dataPoint);\n    }\n    \n    public void clear() {\n        this.root.clear();\n    }\n    \n    public ArrayList retrieve(float x, float y) {\n        return this.root.retrieve(x,y);\n    }\n    \n    public void display() {\n        root.display();\n    }\n}\n    \nclass Node {\n    \n    Bounds bounds = null;\n    Node[] nodes = null;\n    ArrayList dataPoints = new ArrayList();\n    ArrayList dataPointsPartial = new ArrayList();\n    int depth,maxChildren,maxDepth;\n    \n    public Node(Bounds bounds,int depth,int maxDepth,int maxChildren) {\n        this.bounds = bounds;\n        this.depth = depth;\n        this.maxChildren = maxChildren;\n        this.maxDepth = maxDepth;\n    }\n    \n     private void subdivide() {\n        int newDepth = this.depth +1 ;\n        Bounds[] subBounds = bounds.quarter();\n        nodes  = new Node[4];\n        for (int i=0;i<4;i++) {\n           nodes[i] = new Node(subBounds[i],newDepth,maxDepth,maxChildren);    \n        }\n    }\n    \n    public void insert(DataPoint dataPoint) {\n        if (this.nodes != null) {\n            int index = this.findIndex(dataPoint.getX(),dataPoint.getY());\n            Node node = nodes[index];\n    //console.log(node);\n    //      console.log('depth:'+depth);\n            if (node.bounds.pointInside(dataPoint)) {\n                nodes[index].insert(dataPoint);\n            }\n            else {\n    //          console.log('partial' + dataPoint);\n                this.dataPointsPartial.add(dataPoint);\n            }\n            return;\n        }\n        \n        if (!(this.depth >= this.maxDepth) && dataPoints.size() >= this.maxChildren) {\n    /*console.log(bounds);\n            console.log('depth:' + depth);\n    console.log('dataPointSize' + dataPoints.size());*/\n            this.subdivide();\n            insert(dataPoint);\n        }\n        else {\n            dataPoints.add(dataPoint);\n        }\n    }\n    \n    \n    \n    private int findIndex(float x, float y) {\n    /*console.log('x:'+x);\n        console.log('y:'+y);\n    console.log(bounds);*/\n        boolean left = !(x >= bounds.x + bounds.width/2);\n        boolean top = !(y >= bounds.y + bounds.height/2);\n        int index = 0;\n        if (left) {\n             if (!top) {\n                 index = 1;\n             }\n        }\n        else {\n            if (top)\n                index = 2;\n            else \n                index = 3;\n        }\n    //console.log('index:' + index);\n        return index;\n    }\n   \n    public ArrayList retrieve(float x, float y) {\n        ArrayList list = new ArrayList();\n        if (nodes != null) {\n            int index  = findIndex(x,y);\n    //console.log('index:'+ index);\n            list.addAll(nodes[index].retrieve(x,y));\n        }\n               \n        list.addAll(dataPointsPartial);\n        list.addAll(dataPoints);\n    /* console.log('partial:'+ dataPointsPartial.size());\n        console.log('complete:'+dataPoints.size());   \n    console.log('sum:'+list.size());*/\n        return list;\n    }\n    \n    public void clear() {\n        this.dataPointsPartial.clear();\n        this.dataPoints.clear();\n        if (nodes != null) {\n            for (int i =0;i<nodes.length;i++) {\n                nodes[i].clear();\n            }\n            nodes = null;\n        }\n    }\n    \n    public void display() {\n        bounds.display();\n        if (nodes != null) {    \n            for (int i =0;i<nodes.length;i++) {\n                 nodes[i].display();\n            }\n        }\n    }\n}\n    \nclass Bounds {\n    float x,y,width,height;\n    \n    public Bounds(float x,float y,float width,float height) {\n        this.width=width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n    }\n    \n    \n    \n    public boolean pointInside(DataPoint point) {\n    /* console.log('PointX: ' + point.getX() + ' boundX:' + this.x);\n       console.log('PointY: ' + point.getY()+' boundY:' + this.y);\n       console.log('PointX2: ' + float(point.getX())+float(point.getSeparation()) + 'boundX2:' + this.x + this.width);\n    console.log('PointY2: ' + float(point.getY()) + float(point.getSeparation()) + 'boundY2:' + this.y + this.height);*/\n       return point.getX() >= this.x && \n              point.getX() + point.getSeparation() <= this.x + this.width &&\n              point.getY() >= this.y && \n              point.getY() + point.getSeparation() <= this.y + this.height;\n    }\n    \n    public Bounds[] quarter() {\n        float sub_width = this.width/2;\n        float sub_height = this.height/2;\n        Bounds[] bounds = new Bounds[4];\n        bounds[0] = new Bounds(this.x,this.y,sub_width,sub_height);\n        bounds[1] = new Bounds(this.x,this.y+sub_height,sub_width,sub_height);\n        bounds[2] = new Bounds(this.x+sub_width,this.y,sub_width,sub_height);\n        bounds[3] = new Bounds(this.x+sub_width,this.y+sub_height,sub_width,sub_height);\n        return bounds;\n    }\n    \n    public void display() {\n        stroke(0);\n        noFill();\n        rect(x,y,width,height);\n    }\n}"]